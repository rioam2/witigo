package wit

import (
	"encoding/json"

	"github.com/golang-cz/textcase"
	"github.com/moznion/gowrtr/generator"
)

type WitWorldDefinition interface {
	Name() string
	ExportedFunctions() []WitFunction
	String() string
	Codegen() *generator.Root
}

type WitWorldDefinitionImpl struct {
	Raw  json.RawMessage
	Root WitDefinition
}

var _ WitWorldDefinition = &WitWorldDefinitionImpl{}

func (w *WitWorldDefinitionImpl) Name() string {
	var data struct {
		Name string `json:"name"`
	}
	json.Unmarshal(w.Raw, &data)
	return data.Name
}

func (w *WitWorldDefinitionImpl) ExportedFunctions() []WitFunction {
	var data struct {
		Exports map[string]struct {
			Function *json.RawMessage `json:"function"`
		} `json:"exports"`
	}
	json.Unmarshal(w.Raw, &data)
	var functions []WitFunction
	for _, export := range data.Exports {
		if export.Function == nil {
			continue
		}
		functions = append(functions, &WitFunctionImpl{*export.Function, w.Root})
	}
	return functions
}

func (w *WitWorldDefinitionImpl) String() string {
	base := "world " + w.Name() + " {"
	for _, function := range w.ExportedFunctions() {
		base += "\n  export " + function.String()
	}
	base += "\n}"
	return base
}

func (w *WitWorldDefinitionImpl) Codegen() *generator.Root {
	root := generator.NewRoot().AddStatements(
		generator.NewComment(" Code generated by witigo -- DO NOT EDIT"),
		generator.NewComment(" World: "+w.Name()),
		generator.NewNewline(),
		generator.NewPackage(textcase.SnakeCase(w.Root.Name())),
		generator.NewNewline(),
	)
	for _, typeDef := range w.Root.Types() {
		typeGen := typeDef.CodegenGolangTypedef()
		if typeGen == nil {
			continue
		}
		root = root.AddStatements(typeGen, generator.NewNewline())
	}
	for _, function := range w.ExportedFunctions() {
		funcGen := function.Codegen()
		if funcGen == nil {
			continue
		}
		root = root.AddStatements(funcGen, generator.NewNewline())
	}
	return root
}
