package codegen

import (
	"fmt"

	"github.com/golang-cz/textcase"
	"github.com/moznion/gowrtr/generator"
	"github.com/rioam2/witigo/pkg/wit"
)

const contextType = "context.Context"
const instancePointerType = "*Instance"

func GenerateFromWorld(w wit.WitWorldDefinition, packageName string) *generator.Root {
	instanceFuncs := []*generator.FuncSignature{
		generator.NewFuncSignature("Close").
			AddParameters(generator.NewFuncParameter("ctx", contextType)).
			AddReturnTypes("error"),
	}
	for _, f := range w.ExportedFunctions() {
		instanceFuncs = append(instanceFuncs, GenerateSignatureFromFunction(f))
	}

	root := generator.NewRoot().AddStatements(
		generator.NewComment(" Code generated by witigo -- DO NOT EDIT"),
		generator.NewComment(" World: "+w.Name()),
		generator.NewNewline(),
		generator.NewPackage(textcase.SnakeCase(packageName)),
		generator.NewRawStatement("import ("),
		generator.NewRawStatement("	_ \"embed\""),
		generator.NewRawStatement("\"fmt\""),
		generator.NewRawStatement("\"context\""),
		generator.NewNewline(),
		generator.NewRawStatement("\"github.com/rioam2/witigo/pkg/abi\""),
		generator.NewRawStatement("\"github.com/tetratelabs/wazero\""),
		generator.NewRawStatement("\"github.com/tetratelabs/wazero/api\""),
		generator.NewRawStatement("\"github.com/tetratelabs/wazero/imports/wasi_snapshot_preview1\""),
		generator.NewRawStatement(")"),
		generator.NewNewline(),
		generator.NewComment(fmt.Sprintf("go:embed %s_core.wasm", textcase.SnakeCase(packageName))),
		generator.NewRawStatement("var coreModule []byte"),
		generator.NewInterface("instance", instanceFuncs...),
		generator.NewNewline(),
		generator.NewStruct("Instance").
			AddField("runtime", "wazero.Runtime").
			AddField("module", "api.Module").
			AddField("memory", "api.Memory").
			AddField("abiOpts", "abi.AbiOptions").
			AddField("ctx", contextType),
		generator.NewNewline(),
		generator.NewRawStatement("var _ instance = &Instance{}"),
		generator.NewNewline(),
		generator.NewFunc(nil,
			generator.NewFuncSignature("New").
				AddParameters(generator.NewFuncParameter("ctx", contextType)).
				AddReturnTypes(instancePointerType, "error")).
			Statements(
				generator.NewRawStatement("c := wazero.NewRuntimeConfig().WithCloseOnContextDone(true)"),
				generator.NewRawStatement("r := wazero.NewRuntimeWithConfig(ctx, c)"),
				generator.NewRawStatement("if _, err := wasi_snapshot_preview1.Instantiate(ctx, r); err != nil {"),
				generator.NewRawStatement("  return nil, fmt.Errorf(\"failed to instantiate WASI: %w\", err)"),
				generator.NewRawStatement("}"),
				generator.NewRawStatement("cm, err := r.CompileModule(ctx, coreModule)"),
				generator.NewRawStatement("if err != nil {"),
				generator.NewRawStatement("  return nil, fmt.Errorf(\"failed to compile module: %w\", err)"),
				generator.NewRawStatement("}"),
				generator.NewRawStatement("moduleConfig := wazero.NewModuleConfig().WithName(\"\")"),
				generator.NewRawStatement("module, err := r.InstantiateModule(ctx, cm, moduleConfig)"),
				generator.NewRawStatement("if err != nil {"),
				generator.NewRawStatement("  return nil, fmt.Errorf(\"failed to instantiate module: %w\", err)"),
				generator.NewRawStatement("}"),
				generator.NewRawStatement("memory := module.ExportedMemory(\"memory\")"),
				generator.NewRawStatement("if memory == nil {"),
				generator.NewRawStatement("  return nil, fmt.Errorf(\"module does not export memory named 'memory'\")"),
				generator.NewRawStatement("}"),
				generator.NewRawStatement("abiOpts := abi.AbiOptions{"),
				generator.NewRawStatement("  StringEncoding: abi.StringEncodingUTF8,"),
				generator.NewRawStatement("  Memory: memory,"),
				generator.NewRawStatement("  Context: ctx,"),
				generator.NewRawStatement("  Call: abi.GetRuntimeCallFromWazero(module),"),
				generator.NewRawStatement("}"),
				generator.NewRawStatement("return &Instance{runtime: r, module: module, memory: memory, ctx: ctx, abiOpts: abiOpts}, nil"),
			),
		generator.NewNewline(),
		generator.NewFunc(
			generator.NewFuncReceiver("i", instancePointerType),
			generator.NewFuncSignature("Close").
				AddParameters(generator.NewFuncParameter("ctx", contextType)).
				AddReturnTypes("error"),
			generator.NewRawStatement("return i.module.Close(ctx)"),
		),
	)

	// Add static type declaration for Option types
	root = root.AddStatements(
		generator.NewRawStatement("type Option[T any] struct {"),
		generator.NewRawStatement("	IsSome bool"),
		generator.NewRawStatement("	Value  T"),
		generator.NewRawStatement("}"),
		generator.NewNewline(),
	)

	for _, t := range w.Types() {
		typeGen := GenerateTypedefFromType(t)
		if typeGen == nil {
			continue
		}
		root = root.AddStatements(typeGen, generator.NewNewline())
	}

	for _, f := range w.ExportedFunctions() {
		funcGen := GenerateFromFunction(f, generator.NewFuncReceiver("i", instancePointerType))
		if funcGen == nil {
			continue
		}
		root = root.AddStatements(funcGen, generator.NewNewline())
	}

	return root
}
